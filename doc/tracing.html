<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>tracing - Bitcoin Core Developer Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Bitcoin Core Developer Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="user-space-statically-defined-tracing-usdt-for-bitcoin-core"><a class="header" href="#user-space-statically-defined-tracing-usdt-for-bitcoin-core">User-space, Statically Defined Tracing (USDT) for Bitcoin Core</a></h1>
<p>Bitcoin Core includes statically defined tracepoints to allow for more
observability during development, debugging, code review, and production usage.
These tracepoints make it possible to keep track of custom statistics and
enable detailed monitoring of otherwise hidden internals. They have
little to no performance impact when unused.</p>
<pre><code>eBPF and USDT Overview
======================

                ┌──────────────────┐            ┌──────────────┐
                │ tracing script   │            │ bitcoind     │
                │==================│      2.    │==============│
                │  eBPF  │ tracing │      hooks │              │
                │  code  │ logic   │      into┌─┤►tracepoint 1─┼───┐ 3.
                └────┬───┴──▲──────┘          ├─┤►tracepoint 2 │   │ pass args
            1.       │      │ 4.              │ │ ...          │   │ to eBPF
    User    compiles │      │ pass data to    │ └──────────────┘   │ program
    Space    &amp; loads │      │ tracing script  │                    │
    ─────────────────┼──────┼─────────────────┼────────────────────┼───
    Kernel           │      │                 │                    │
    Space       ┌──┬─▼──────┴─────────────────┴────────────┐       │
                │  │  eBPF program                         │◄──────┘
                │  └───────────────────────────────────────┤
                │ eBPF kernel Virtual Machine (sandboxed)  │
                └──────────────────────────────────────────┘

1. The tracing script compiles the eBPF code and loads the eBPF program into a kernel VM
2. The eBPF program hooks into one or more tracepoints
3. When the tracepoint is called, the arguments are passed to the eBPF program
4. The eBPF program processes the arguments and returns data to the tracing script
</code></pre>
<p>The Linux kernel can hook into the tracepoints during runtime and pass data to
sandboxed <a href="https://ebpf.io/">eBPF</a> programs running in the kernel. These eBPF programs can, for
example, collect statistics or pass data back to user-space scripts for further
processing.</p>
<p>The two main eBPF front-ends with support for USDT are <a href="https://github.com/iovisor/bpftrace">bpftrace</a> and
<a href="https://github.com/iovisor/bcc">BPF Compiler Collection (BCC)</a>. BCC is used for complex tools and daemons and
<code>bpftrace</code> is preferred for one-liners and shorter scripts. Examples for both can
be found in <a href="../contrib/tracing/">contrib/tracing</a>.</p>
<h2 id="tracepoint-documentation"><a class="header" href="#tracepoint-documentation">Tracepoint documentation</a></h2>
<p>The currently available tracepoints are listed here.</p>
<h3 id="context-net"><a class="header" href="#context-net">Context <code>net</code></a></h3>
<h4 id="tracepoint-netinbound_message"><a class="header" href="#tracepoint-netinbound_message">Tracepoint <code>net:inbound_message</code></a></h4>
<p>Is called when a message is received from a peer over the P2P network. Passes
information about our peer, the connection and the message as arguments.</p>
<p>Arguments passed:</p>
<ol>
<li>Peer ID as <code>int64</code></li>
<li>Peer Address and Port (IPv4, IPv6, Tor v3, I2P, ...) as <code>pointer to C-style String</code> (max. length 68 characters)</li>
<li>Connection Type (inbound, feeler, outbound-full-relay, ...) as <code>pointer to C-style String</code> (max. length 20 characters)</li>
<li>Message Type (inv, ping, getdata, addrv2, ...) as <code>pointer to C-style String</code> (max. length 20 characters)</li>
<li>Message Size in bytes as <code>uint64</code></li>
<li>Message Bytes as <code>pointer to unsigned chars</code> (i.e. bytes)</li>
</ol>
<p>Note: The message is passed to the tracepoint in full, however, due to space
limitations in the eBPF kernel VM it might not be possible to pass the message
to user-space in full. Messages longer than a 32kb might be cut off. This can
be detected in tracing scripts by comparing the message size to the length of
the passed message.</p>
<h4 id="tracepoint-netoutbound_message"><a class="header" href="#tracepoint-netoutbound_message">Tracepoint <code>net:outbound_message</code></a></h4>
<p>Is called when a message is sent to a peer over the P2P network. Passes
information about our peer, the connection and the message as arguments.</p>
<p>Arguments passed:</p>
<ol>
<li>Peer ID as <code>int64</code></li>
<li>Peer Address and Port (IPv4, IPv6, Tor v3, I2P, ...) as <code>pointer to C-style String</code> (max. length 68 characters)</li>
<li>Connection Type (inbound, feeler, outbound-full-relay, ...) as <code>pointer to C-style String</code> (max. length 20 characters)</li>
<li>Message Type (inv, ping, getdata, addrv2, ...) as <code>pointer to C-style String</code> (max. length 20 characters)</li>
<li>Message Size in bytes as <code>uint64</code></li>
<li>Message Bytes as <code>pointer to unsigned chars</code> (i.e. bytes)</li>
</ol>
<p>Note: The message is passed to the tracepoint in full, however, due to space
limitations in the eBPF kernel VM it might not be possible to pass the message
to user-space in full. Messages longer than a 32kb might be cut off. This can
be detected in tracing scripts by comparing the message size to the length of
the passed message.</p>
<h3 id="context-validation"><a class="header" href="#context-validation">Context <code>validation</code></a></h3>
<h4 id="tracepoint-validationblock_connected"><a class="header" href="#tracepoint-validationblock_connected">Tracepoint <code>validation:block_connected</code></a></h4>
<p>Is called <em>after</em> a block is connected to the chain. Can, for example, be used
to benchmark block connections together with <code>-reindex</code>.</p>
<p>Arguments passed:</p>
<ol>
<li>Block Header Hash as <code>pointer to unsigned chars</code> (i.e. 32 bytes in little-endian)</li>
<li>Block Height as <code>int32</code></li>
<li>Transactions in the Block as <code>uint64</code></li>
<li>Inputs spend in the Block as <code>int32</code></li>
<li>SigOps in the Block (excluding coinbase SigOps) <code>uint64</code></li>
<li>Time it took to connect the Block in nanoseconds (ns) as <code>uint64</code></li>
</ol>
<h3 id="context-utxocache"><a class="header" href="#context-utxocache">Context <code>utxocache</code></a></h3>
<p>The following tracepoints cover the in-memory UTXO cache. UTXOs are, for example,
added to and removed (spent) from the cache when we connect a new block.
<strong>Note</strong>: Bitcoin Core uses temporary clones of the <em>main</em> UTXO cache
(<code>chainstate.CoinsTip()</code>). For example, the RPCs <code>generateblock</code> and
<code>getblocktemplate</code> call <code>TestBlockValidity()</code>, which applies the UTXO set
changes to a temporary cache. Similarly, mempool consistency checks, which are
frequent on regtest, also apply the UTXO set changes to a temporary cache.
Changes to the <em>main</em> UTXO cache and to temporary caches trigger the tracepoints.
We can't tell if a temporary cache or the <em>main</em> cache was changed.</p>
<h4 id="tracepoint-utxocacheflush"><a class="header" href="#tracepoint-utxocacheflush">Tracepoint <code>utxocache:flush</code></a></h4>
<p>Is called <em>after</em> the in-memory UTXO cache is flushed.</p>
<p>Arguments passed:</p>
<ol>
<li>Time it took to flush the cache microseconds as <code>int64</code></li>
<li>Flush state mode as <code>uint32</code>. It's an enumerator class with values <code>0</code>
(<code>NONE</code>), <code>1</code> (<code>IF_NEEDED</code>), <code>2</code> (<code>PERIODIC</code>), <code>3</code> (<code>ALWAYS</code>)</li>
<li>Cache size (number of coins) before the flush as <code>uint64</code></li>
<li>Cache memory usage in bytes as <code>uint64</code></li>
<li>If pruning caused the flush as <code>bool</code></li>
</ol>
<h4 id="tracepoint-utxocacheadd"><a class="header" href="#tracepoint-utxocacheadd">Tracepoint <code>utxocache:add</code></a></h4>
<p>Is called when a coin is added to a UTXO cache. This can be a temporary UTXO cache too.</p>
<p>Arguments passed:</p>
<ol>
<li>Transaction ID (hash) as <code>pointer to unsigned chars</code> (i.e. 32 bytes in little-endian)</li>
<li>Output index as <code>uint32</code></li>
<li>Block height the coin was added to the UTXO-set as  <code>uint32</code></li>
<li>Value of the coin as <code>int64</code></li>
<li>If the coin is a coinbase as <code>bool</code></li>
</ol>
<h4 id="tracepoint-utxocachespent"><a class="header" href="#tracepoint-utxocachespent">Tracepoint <code>utxocache:spent</code></a></h4>
<p>Is called when a coin is spent from a UTXO cache. This can be a temporary UTXO cache too.</p>
<p>Arguments passed:</p>
<ol>
<li>Transaction ID (hash) as <code>pointer to unsigned chars</code> (i.e. 32 bytes in little-endian)</li>
<li>Output index as <code>uint32</code></li>
<li>Block height the coin was spent, as <code>uint32</code></li>
<li>Value of the coin as <code>int64</code></li>
<li>If the coin is a coinbase as <code>bool</code></li>
</ol>
<h4 id="tracepoint-utxocacheuncache"><a class="header" href="#tracepoint-utxocacheuncache">Tracepoint <code>utxocache:uncache</code></a></h4>
<p>Is called when a coin is purposefully unloaded from a UTXO cache. This
happens, for example, when we load an UTXO into a cache when trying to accept
a transaction that turns out to be invalid. The loaded UTXO is uncached to avoid
filling our UTXO cache up with irrelevant UTXOs.</p>
<p>Arguments passed:</p>
<ol>
<li>Transaction ID (hash) as <code>pointer to unsigned chars</code> (i.e. 32 bytes in little-endian)</li>
<li>Output index as <code>uint32</code></li>
<li>Block height the coin was uncached, as <code>uint32</code></li>
<li>Value of the coin as <code>int64</code></li>
<li>If the coin is a coinbase as <code>bool</code></li>
</ol>
<h3 id="context-coin_selection"><a class="header" href="#context-coin_selection">Context <code>coin_selection</code></a></h3>
<h4 id="tracepoint-coin_selectionselected_coins"><a class="header" href="#tracepoint-coin_selectionselected_coins">Tracepoint <code>coin_selection:selected_coins</code></a></h4>
<p>Is called when <code>SelectCoins</code> completes.</p>
<p>Arguments passed:</p>
<ol>
<li>Wallet name as <code>pointer to C-style string</code></li>
<li>Coin selection algorithm name as <code>pointer to C-style string</code></li>
<li>Selection target value as <code>int64</code></li>
<li>Calculated waste metric of the solution as <code>int64</code></li>
<li>Total value of the selected inputs as <code>int64</code></li>
</ol>
<h4 id="tracepoint-coin_selectionnormal_create_tx_internal"><a class="header" href="#tracepoint-coin_selectionnormal_create_tx_internal">Tracepoint <code>coin_selection:normal_create_tx_internal</code></a></h4>
<p>Is called when the first <code>CreateTransactionInternal</code> completes.</p>
<p>Arguments passed:</p>
<ol>
<li>Wallet name as <code>pointer to C-style string</code></li>
<li>Whether <code>CreateTransactionInternal</code> succeeded as <code>bool</code></li>
<li>The expected transaction fee as an <code>int64</code></li>
<li>The position of the change output as an <code>int32</code></li>
</ol>
<h4 id="tracepoint-coin_selectionattempting_aps_create_tx"><a class="header" href="#tracepoint-coin_selectionattempting_aps_create_tx">Tracepoint <code>coin_selection:attempting_aps_create_tx</code></a></h4>
<p>Is called when <code>CreateTransactionInternal</code> is called the second time for the optimistic
Avoid Partial Spends selection attempt. This is used to determine whether the next
tracepoints called are for the Avoid Partial Spends solution, or a different transaction.</p>
<p>Arguments passed:</p>
<ol>
<li>Wallet name as <code>pointer to C-style string</code></li>
</ol>
<h4 id="tracepoint-coin_selectionaps_create_tx_internal"><a class="header" href="#tracepoint-coin_selectionaps_create_tx_internal">Tracepoint <code>coin_selection:aps_create_tx_internal</code></a></h4>
<p>Is called when the second <code>CreateTransactionInternal</code> with Avoid Partial Spends enabled completes.</p>
<p>Arguments passed:</p>
<ol>
<li>Wallet name as <code>pointer to C-style string</code></li>
<li>Whether the Avoid Partial Spends solution will be used as <code>bool</code></li>
<li>Whether <code>CreateTransactionInternal</code> succeeded as<code> bool</code></li>
<li>The expected transaction fee as an <code>int64</code></li>
<li>The position of the change output as an <code>int32</code></li>
</ol>
<h3 id="context-mempool"><a class="header" href="#context-mempool">Context <code>mempool</code></a></h3>
<h4 id="tracepoint-mempooladded"><a class="header" href="#tracepoint-mempooladded">Tracepoint <code>mempool:added</code></a></h4>
<p>Is called when a transaction is added to the node's mempool. Passes information
about the transaction.</p>
<p>Arguments passed:</p>
<ol>
<li>Transaction ID (hash) as <code>pointer to unsigned chars</code> (i.e. 32 bytes in little-endian)</li>
<li>Transaction virtual size as <code>int32</code></li>
<li>Transaction fee as <code>int64</code></li>
</ol>
<h4 id="tracepoint-mempoolremoved"><a class="header" href="#tracepoint-mempoolremoved">Tracepoint <code>mempool:removed</code></a></h4>
<p>Is called when a transaction is removed from the node's mempool. Passes information
about the transaction.</p>
<p>Arguments passed:</p>
<ol>
<li>Transaction ID (hash) as <code>pointer to unsigned chars</code> (i.e. 32 bytes in little-endian)</li>
<li>Removal reason as <code>pointer to C-style String</code> (max. length 9 characters)</li>
<li>Transaction virtual size as <code>int32</code></li>
<li>Transaction fee as <code>int64</code></li>
<li>Transaction mempool entry time (epoch) as <code>uint64</code></li>
</ol>
<h4 id="tracepoint-mempoolreplaced"><a class="header" href="#tracepoint-mempoolreplaced">Tracepoint <code>mempool:replaced</code></a></h4>
<p>Is called when a transaction in the node's mempool is getting replaced by another.
Passes information about the replaced and replacement transactions.</p>
<p>Arguments passed:</p>
<ol>
<li>Replaced transaction ID (hash) as <code>pointer to unsigned chars</code> (i.e. 32 bytes in little-endian)</li>
<li>Replaced transaction virtual size as <code>int32</code></li>
<li>Replaced transaction fee as <code>int64</code></li>
<li>Replaced transaction mempool entry time (epoch) as <code>uint64</code></li>
<li>Replacement transaction ID (hash) as <code>pointer to unsigned chars</code> (i.e. 32 bytes in little-endian)</li>
<li>Replacement transaction virtual size as <code>int32</code></li>
<li>Replacement transaction fee as <code>int64</code></li>
</ol>
<p>Note: In cases where a single replacement transaction replaces multiple
existing transactions in the mempool, the tracepoint is called once for each
replaced transaction, with data of the replacement transaction being the same
in each call.</p>
<h4 id="tracepoint-mempoolrejected"><a class="header" href="#tracepoint-mempoolrejected">Tracepoint <code>mempool:rejected</code></a></h4>
<p>Is called when a transaction is not permitted to enter the mempool. Passes
information about the rejected transaction.</p>
<p>Arguments passed:</p>
<ol>
<li>Transaction ID (hash) as <code>pointer to unsigned chars</code> (i.e. 32 bytes in little-endian)</li>
<li>Reject reason as <code>pointer to C-style String</code> (max. length 118 characters)</li>
</ol>
<h2 id="adding-tracepoints-to-bitcoin-core"><a class="header" href="#adding-tracepoints-to-bitcoin-core">Adding tracepoints to Bitcoin Core</a></h2>
<p>Use the <code>TRACEPOINT</code> macro to add a new tracepoint. If not yet included, include
<code>util/trace.h</code> (defines the tracepoint macros) with <code>#include &lt;util/trace.h&gt;</code>.
Each tracepoint needs a <code>context</code> and an <code>event</code>. Please use <code>snake_case</code> and
try to make sure that the tracepoint names make sense even without detailed
knowledge of the implementation details. You can pass zero to twelve arguments
to the tracepoint. Each tracepoint also needs a global semaphore. The semaphore
gates the tracepoint arguments from being processed if we are not attached to
the tracepoint. Add a <code>TRACEPOINT_SEMAPHORE(context, event)</code> with the <code>context</code>
and <code>event</code> of your tracepoint in the top-level namespace at the beginning of
the file. Do not forget to update the tracepoint list in this document.</p>
<p>For example, the <code>net:outbound_message</code> tracepoint in <code>src/net.cpp</code> with six
arguments.</p>
<pre><code class="language-C++">// src/net.cpp
TRACEPOINT_SEMAPHORE(net, outbound_message);
…
void CConnman::PushMessage(…) {
  …
  TRACEPOINT(net, outbound_message,
      pnode-&gt;GetId(),
      pnode-&gt;m_addr_name.c_str(),
      pnode-&gt;ConnectionTypeAsString().c_str(),
      sanitizedType.c_str(),
      msg.data.size(),
      msg.data.data()
  );
  …
}
</code></pre>
<p>If needed, an extra <code>if (TRACEPOINT_ACTIVE(context, event)) {...}</code> check can be
used to prepare somewhat expensive arguments right before the tracepoint. While
the tracepoint arguments are only prepared when we attach something to the
tracepoint, an argument preparation should never hang the process. Hashing and
serialization of data structures is probably fine, a <code>sleep(10s)</code> not.</p>
<pre><code class="language-C++">// An example tracepoint with an expensive argument.

TRACEPOINT_SEMAPHORE(example, gated_expensive_argument);
…
if (TRACEPOINT_ACTIVE(example, gated_expensive_argument)) {
    expensive_argument = expensive_calulation();
    TRACEPOINT(example, gated_expensive_argument, expensive_argument);
}
</code></pre>
<h3 id="guidelines-and-best-practices"><a class="header" href="#guidelines-and-best-practices">Guidelines and best practices</a></h3>
<h4 id="clear-motivation-and-use-case"><a class="header" href="#clear-motivation-and-use-case">Clear motivation and use case</a></h4>
<p>Tracepoints need a clear motivation and use case. The motivation should
outweigh the impact on, for example, code readability. There is no point in
adding tracepoints that don't end up being used.</p>
<h4 id="provide-an-example"><a class="header" href="#provide-an-example">Provide an example</a></h4>
<p>When adding a new tracepoint, provide an example. Examples can show the use case
and help reviewers testing that the tracepoint works as intended. The examples
can be kept simple but should give others a starting point when working with
the tracepoint. See existing examples in <a href="../contrib/tracing/">contrib/tracing/</a>.</p>
<h4 id="semi-stable-api"><a class="header" href="#semi-stable-api">Semi-stable API</a></h4>
<p>Tracepoints should have a semi-stable API. Users should be able to rely on the
tracepoints for scripting. This means tracepoints need to be documented, and the
argument order ideally should not change. If there is an important reason to
change argument order, make sure to document the change and update the examples
using the tracepoint.</p>
<h4 id="ebpf-virtual-machine-limits"><a class="header" href="#ebpf-virtual-machine-limits">eBPF Virtual Machine limits</a></h4>
<p>Keep the eBPF Virtual Machine limits in mind. eBPF programs receiving data from
the tracepoints run in a sandboxed Linux kernel VM. This VM has a limited stack
size of 512 bytes. Check if it makes sense to pass larger amounts of data, for
example, with a tracing script that can handle the passed data.</p>
<h4 id="bpftrace-argument-limit"><a class="header" href="#bpftrace-argument-limit"><code>bpftrace</code> argument limit</a></h4>
<p>While tracepoints can have up to 12 arguments, bpftrace scripts currently only
support reading from the first six arguments (<code>arg0</code> till <code>arg5</code>) on <code>x86_64</code>.
bpftrace currently lacks real support for handling and printing binary data,
like block header hashes and txids. When a tracepoint passes more than six
arguments, then string and integer arguments should preferably be placed in the
first six argument fields. Binary data can be placed in later arguments. The BCC
supports reading from all 12 arguments.</p>
<h4 id="strings-as-c-style-string"><a class="header" href="#strings-as-c-style-string">Strings as C-style String</a></h4>
<p>Generally, strings should be passed into the <code>TRACEPOINT</code> macros as pointers to
C-style strings (a null-terminated sequence of characters). For C++
<code>std::strings</code>, <a href="https://www.cplusplus.com/reference/string/string/c_str/"><code>c_str()</code></a>  can be used. It's recommended to document the
maximum expected string size if known.</p>
<h2 id="listing-available-tracepoints"><a class="header" href="#listing-available-tracepoints">Listing available tracepoints</a></h2>
<p>Multiple tools can list the available tracepoints in a <code>bitcoind</code> binary with
USDT support.</p>
<h3 id="gdb---gnu-project-debugger"><a class="header" href="#gdb---gnu-project-debugger">GDB - GNU Project Debugger</a></h3>
<p>To list probes in Bitcoin Core, use <code>info probes</code> in <code>gdb</code>:</p>
<pre><code>$ gdb ./build/src/bitcoind
…
(gdb) info probes
Type Provider   Name             Where              Semaphore Object
stap net        inbound_message  0x000000000014419e 0x0000000000d29bd2 /build/src/bitcoind
stap net        outbound_message 0x0000000000107c05 0x0000000000d29bd0 /build/src/bitcoind
stap validation block_connected  0x00000000002fb10c 0x0000000000d29bd8 /build/src/bitcoind
…
</code></pre>
<h3 id="with-readelf"><a class="header" href="#with-readelf">With <code>readelf</code></a></h3>
<p>The <code>readelf</code> tool can be used to display the USDT tracepoints in Bitcoin Core.
Look for the notes with the description <code>NT_STAPSDT</code>.</p>
<pre><code>$ readelf -n ./build/src/bitcoind | grep NT_STAPSDT -A 4 -B 2
Displaying notes found in: .note.stapsdt
  Owner                 Data size	Description
  stapsdt              0x0000005d	NT_STAPSDT (SystemTap probe descriptors)
    Provider: net
    Name: outbound_message
    Location: 0x0000000000107c05, Base: 0x0000000000579c90, Semaphore: 0x0000000000d29bd0
    Arguments: -8@%r12 8@%rbx 8@%rdi 8@192(%rsp) 8@%rax 8@%rdx
…
</code></pre>
<h3 id="with-tplist"><a class="header" href="#with-tplist">With <code>tplist</code></a></h3>
<p>The <code>tplist</code> tool is provided by BCC (see <a href="https://github.com/iovisor/bcc/blob/master/INSTALL.md">Installing BCC</a>). It displays kernel
tracepoints or USDT probes and their formats (for more information, see the
<a href="https://github.com/iovisor/bcc/blob/master/tools/tplist_example.txt"><code>tplist</code> usage demonstration</a>). There are slight binary naming differences
between distributions. For example, on
<a href="https://github.com/iovisor/bcc/blob/master/INSTALL.md#ubuntu---binary">Ubuntu the binary is called <code>tplist-bpfcc</code></a>.</p>
<pre><code>$ tplist -l ./build/src/bitcoind -v
b'net':b'outbound_message' [sema 0xd29bd0]
  1 location(s)
  6 argument(s)
…
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../doc/tor.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../doc/translation_process.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../doc/tor.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../doc/translation_process.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
